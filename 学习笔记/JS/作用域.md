## 编译原理

在编程语言中，写出来的程序是要经过编译和其它工作才能够变为可执行程序的，基本步骤有这么三大步：

1. 词法分析

## 作用域

学习过编程语言的都知道，在编程语言中把数据存储变量当中是一个最为基本的功能，并且能够在之后快速的访问和修改变量。人们设计了一套规则来存储变量，方便在以后需要的时候能够尽快的找到这些变量，这套规则就叫做作用域。

对于赋值操作需要介绍`LHS`和`RHS`这两个概念，`LHS`和`RHS`分别表示的是赋值操作的左侧和右侧。

这里是需要注意不要认为`LHS`和`RHS`就是`=`的左侧和右侧，因为赋值操作不单单是以`=`这种形式，还有函数在传参的时候也会进行赋值操作。

对于为对象赋值就需要利用`LHS`查询，如果是需要获取对象里面的值，那么就需要利用`RHS`查询。

`JS`引擎在执行程序前，会先抽出少量时间对程序进行编译，在编译过程中编译器会进行词法分析和语法分析，并且会在语法分析后生成语法树，最终会根据语法树生成可执行的程序。在最后生成代码的过程中，编译器会查找声明的变量，如果该变量已经存在于同一个作用域的集合中，那么编译器会忽略；如果没有查找到该变量，那么编译器会为该变量分配一块内存。

对于`var a = 2`这样的语句，编译器在生成代码的时候，如果在作用域中没有找到变量`a`，会为变量`a`分配内存空间。`JS`引擎在执行程序的时候会以`LHS`的方式在作用域里面寻找名字叫做变量为`a`的标签，如果当前作用域没有找到该变量，那么`JS`引擎会沿着作用域链继续向上查找，直到查找到`a`这个标签，那么才会停止查找，并且将2这个值赋值给`a`。如果最终都没有查找到，那么`JS`引擎就会进行`ReferenceError`异常

作用域又分为词法作用域和动态作用域。

### 词法作用域

编译器在第一个工作阶段叫做词法化，会对代码中的每个字符进行检查，这样同时方便对词法作用域的确定。

这个概念的定义就是指：词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是根据你写代码时讲变量还有作用域写在哪里来决定的。当编译器编译的时候会保持作用域不变(有两种特殊情况)。

那么什么情况才会产生作用域？产生的每个作用域是相同类型的吗？

#### 函数作用域

每一个函数都会产生一个作用域，称为函数作用域，来看一个简单的例子

```js
function foo(a) {
  function bar(b) {
    console.log(b)
  }
  let c = 3
}
console.log(c)
```

这个例子有三层作用域，分别是`bar`函数、`foo`函数、全局作用域嵌套构成。

嵌套的作用域形成了作用域链，最里层的`bar`函数可以沿着作用域访问外层作用域直到全局作用域，而外层作用域的变量或者函数不能访问内层作用域，这就有了下面几个好处：

1. 隐藏内部实现

可以通过将任意代码片段放入到函数内部，因为外部作用域无法访问内层的作用域，那么为了防止内部代码暴

露，达到隐藏的目的

2. 规避冲突

JS引擎执行查找变量时，会在找到距离当前作用域最近的作用域的同名变量，就会停止查找。而外层也不会访问

到里层的同名变量，也就不会造成程序的模棱两可，也就能够被正确解析。

#### 块作用域

在块作用之前，要想实现作用域包含代码片段，使用具名函数虽然解决了代码片段的隐藏，但是新出现的函数的函数名也会对当前作用域造成污染，为了解决这个问题，社区实现了立即执行函数表达式

```js
let a = 2

(function foo() {
  let a = 3
  console.log(a)
})()

console.log(a)
```

但是立即函数表达不方便，块作用域随之孕育而生。